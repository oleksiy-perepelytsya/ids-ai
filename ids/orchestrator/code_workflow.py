"""Code generation workflow orchestration"""

from pathlib import Path
from typing import Optional

from ids.models import DevSession, SessionStatus
from ids.models.code_task import CodeResult, CodeContext, CodeChange, CodeOperation
from ids.services.python_analyzer import PythonAnalyzer
from ids.services.file_manager import FileManager
from ids.services.validation_engine import ValidationEngine
from ids.utils import get_logger

logger = get_logger(__name__)


class CodeWorkflow:
    """
    Orchestrate code generation and modification workflow.
    Extends the deliberation system with code operations.
    """
    
    def __init__(
        self,
        file_manager: FileManager,
        analyzer: PythonAnalyzer,
        validator: ValidationEngine
    ):
        """
        Initialize code workflow.
        
        Args:
            file_manager: File operation manager
            analyzer: Python code analyzer
            validator: Validation engine
        """
        self.file_manager = file_manager
        self.analyzer = analyzer
        self.validator = validator
    
    async def execute_code_task(
        self,
        session: DevSession,
        code_context: CodeContext,
        generated_code: str,
        target_file: Path
    ) -> CodeResult:
        """
        Execute a code task with validation.
        Phase 2: No auto-fix, just validate and report.
        
        Args:
            session: Current session
            code_context: Code operation context  
            generated_code: Code generated by agents
            target_file: Target file to write
            
        Returns:
            CodeResult with outcome
        """
        logger.info("executing_code_task", 
                   session_id=session.session_id,
                   target=str(target_file))
        
        # Step 1: Validate syntax first
        syntax_result = self.validator.validate_syntax(generated_code, str(target_file))
        
        if not syntax_result.passed:
            logger.warning("syntax_validation_failed", 
                          errors=syntax_result.errors)
            return CodeResult(
                success=False,
                changes=[],
                validation_summary=self.validator.format_results([syntax_result]),
                error_message=f"Syntax errors: {', '.join(syntax_result.errors)}",
                iterations=1
            )
        
        # Step 2: Write file with backup
        write_success = self.file_manager.write_file(
            filepath=target_file,
            content=generated_code,
            session_id=session.session_id,
            create_backup=True
        )
        
        if not write_success:
            return CodeResult(
                success=False,
                changes=[],
                validation_summary="Failed to write file",
                error_message="File write operation failed",
                iterations=1
            )
        
        # Step 3: Run full validation on written file
        validation_results = self.validator.validate_file(target_file)
        
        # Check if validation passed
        all_passed = all(r.passed for r in validation_results)
        validation_summary = self.validator.format_results(validation_results)
        
        if not all_passed:
            logger.warning("validation_failed_rolling_back",
                          target=str(target_file))
            # Rollback the change
            self.file_manager.rollback_file(target_file)
            
            return CodeResult(
                success=False,
                changes=[],
                validation_summary=validation_summary,
                error_message="Validation failed, changes rolled back",
                iterations=1
            )
        
        # Success!
        logger.info("code_task_completed", target=str(target_file))
        
        operation = CodeOperation.CREATE if not target_file.exists() else CodeOperation.MODIFY
        
        return CodeResult(
            success=True,
            changes=[CodeChange(
                filepath=str(target_file),
                operation=operation,
                content=generated_code,
                backup_path=str(self.file_manager.backups.get(str(target_file)).backup_path)
                    if str(target_file) in self.file_manager.backups else None
            )],
            validation_summary=validation_summary,
            error_message=None,
            iterations=1
        )
    
    async def analyze_project(self, project_path: Path) -> dict:
        """
        Analyze a Python project structure.
        
        Args:
            project_path: Root path of project
            
        Returns:
            Dictionary with project analysis
        """
        logger.info("analyzing_project", path=str(project_path))
        
        analysis = {
            "path": str(project_path),
            "files": [],
            "total_functions": 0,
            "total_classes": 0,
            "imports": set()
        }
        
        # Find all Python files
        python_files = list(project_path.rglob("*.py"))
        
        for py_file in python_files:
            file_info = self.analyzer.analyze_file(py_file)
            if file_info:
                analysis["files"].append({
                    "path": str(py_file.relative_to(project_path)),
                    "functions": len(file_info.functions),
                    "classes": len(file_info.classes)
                })
                analysis["total_functions"] += len(file_info.functions)
                analysis["total_classes"] += len(file_info.classes)
                analysis["imports"].update(file_info.imports)
        
        analysis["imports"] = sorted(list(analysis["imports"]))
        
        logger.info("project_analysis_complete",
                   files=len(python_files),
                   functions=analysis["total_functions"],
                   classes=analysis["total_classes"])
        
        return analysis
    
    def build_code_context(
        self,
        project_path: Path,
        target_files: list[str],
        task_description: str
    ) -> str:
        """
        Build context string for LLM code generation.
        
        Args:
            project_path: Project root
            target_files: Files to include in context
            task_description: What to do
            
        Returns:
            Formatted context string
        """
        lines = [
            f"Task: {task_description}",
            f"",
            f"Project: {project_path.name}",
            f""
        ]
        
        # Analyze target files
        for target_file in target_files:
            file_path = project_path / target_file
            if file_path.exists():
                file_info = self.analyzer.analyze_file(file_path)
                if file_info:
                    lines.append(self.analyzer.build_context_summary(file_info))
                    lines.append("")
        
        return "\n".join(lines)
